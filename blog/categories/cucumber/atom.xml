<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cucumber | developerof.com]]></title>
  <link href="http://www.developerof.com/blog/categories/cucumber/atom.xml" rel="self"/>
  <link href="http://www.developerof.com/"/>
  <updated>2012-09-14T15:59:34+02:00</updated>
  <id>http://www.developerof.com/</id>
  <author>
    <name><![CDATA[István Pató]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Road To Continuous Delivery]]></title>
    <link href="http://www.developerof.com/blog/2012/09/08/the-road-to-continuous-delivery/"/>
    <updated>2012-09-08T18:35:00+02:00</updated>
    <id>http://www.developerof.com/blog/2012/09/08/the-road-to-continuous-delivery</id>
    <content type="html"><![CDATA[<p>I've been working at my company since 1997. I've created with my team more than 36 Java web application and 29 Oracle database.
When we started at 1997, we had just an email server, a version control (CVS) server and a bug reporting system.
We didn't write unit test just Java main methods, and we didn't hear about integration test.
Few years later we have started writing unit tests, and more few years later integration tests.
<img class="left" src="/images/post/cucumber-report.png" title="Cucumber report" >
Today, we have been using several continuous integration and delivery tools: Redmine, Maven, Jenkins, DVCS, Selenium/WebDriver, JUnit, Cucumber.
To be able to achieve continuous delivery, it has to start with continuous integration.
Of course, we are developing our process: we have some weakness and we can find new challenges. Before you start a continuous delivery process, your company must be mature. It's all about efficiency.</p>

<blockquote><p>Continuous delivery is able to raise your efficiency.</p></blockquote>

<p>Before you start Continuous Delivery or Continuous Integration, check this list:</p>

<!--more-->


<h3>Software Configuration Management</h3>

<ol>
<li>Creating a new developer environment takes about 30 minutes.</li>
<li>Version number syntax is carved in stone (snapshots and releases).</li>
<li>You can create 'one step build'.</li>
<li>Your build repeatable.</li>
<li>You have runtime environment names.</li>
<li>Code is able to running on developer machine.</li>
<li>You have a Wiki, and a page with description of SCM.</li>
<li>Lead Developer is a 'software configuration master' (master and no manager).</li>
<li>You've a bug, task, feature database.</li>
</ol>


<h3>Developer activities</h3>

<ol>
<li>Developer fixes bugs before writing new code.</li>
<li>Developer always writes a unit test to reproduce a bug before start a bug fixing.</li>
<li>Developer can prove the issues have been fixed (unit test, integration test).</li>
<li>Developer can reproduce a bug on the developer machine, or at least not in the production environment.</li>
<li>Developer knows what the project goal is.</li>
<li>Developer knows what she/he is working on today and tomorrow.</li>
<li>Developers have guidelines: coding style, specification, etc.</li>
</ol>


<h3>Team</h3>

<ol>
<li>You have a TEAM. Not programmers, not testers, not designers, not managers.</li>
<li>Team size between 3-8 people.</li>
<li>Team is older than 3 months.</li>
<li>Team is self organized.</li>
<li>Team visualizes up-to-date their own work, schedules and impediments.</li>
<li>Team's able to carry out specifications, codes, automatic tests and releases.</li>
<li>Team has been continuously developing their own process.</li>
<li>Team is independent of other teams (or individuals).</li>
<li>One team - one mission. One mission - one team.</li>
</ol>


<h3>Plan</h3>

<ol>
<li>Product has a feature list (product backlog).</li>
<li>You have a roadmap.</li>
<li>You are able to do less.</li>
<li>Product has validated before it's releasing to production.</li>
<li>All plans have been visualized for teams (Kanban, Scrum).</li>
</ol>


<h2>Conclusion</h2>

<p><img class="left" src="/images/post/jenkins.png" title="Jenkins" >
To achieve continuous delivery: it's not a revolution, it's an evolution. You need a matured company, so
in first stage: check the list, and try to achieve goals, and do not forget: to be able to achieve continuous delivery, it has to start with continuous integration.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lean Tools of Continuous Delivery]]></title>
    <link href="http://www.developerof.com/blog/2012/09/02/lean-tools-of-continuous-delivery/"/>
    <updated>2012-09-02T11:02:00+02:00</updated>
    <id>http://www.developerof.com/blog/2012/09/02/lean-tools-of-continuous-delivery</id>
    <content type="html"><![CDATA[<p>In the past, I have seen a development team who optimized a part of the development process. They focused on write of Java code and automated some code generation. Of course, they have been failed in delivery software. Today we have <a href="http://www.poppendieck.com/">Lean Software Development</a>, so we know what it means <strong>Optimize the Whole</strong> and <strong>Focus on the Entire Value Stream</strong>.</p>

<p>We have been using several tools and methods at <a href="http://www.jurahungaria.com">my software development team</a> and we focus on the entire value stream. <em>Lean mentality requires lean tools and conscious choice!</em></p>

<!--more-->


<h2>Discussions and planning</h2>

<p>Tools: <em>Scrum, Whiteboard, Sketchbook, UML notation, Wiki, Email, Chat</em></p>

<p><img class="left" src="/images/post/sketchbook.jpg" title="Use sketchbook!" >
We've been collecting continuously all requirements, because they are constantly changing. Your best friends are sketchbook and whiteboard. I'm drawing diagrams, screens, data blocks with connections, etc. I’ve always been a big fan of visualization. After all, I've publishing results: wiki, email, product backlog, etc. <em>Do not forget to eliminate waste!</em> Throws out heavyweight and unnecessary tools.</p>

<h2>Continuous delivery</h2>

<p>Tools: <em>NetBeans, DVCS, Apache Maven, JUnit, Spring, Automated Integration Test, Automated Acceptance Test, User Acceptance Test, WebDriver, Cucumber, jMeter, Code review, Logging, Redmine</em></p>

<p>Please, do not optimize just one part of development process! Optimize the whole process from start to finish! <a href="http://en.wikipedia.org/wiki/Continuous_delivery">Continuous delivery</a> helps your team to deliver fast and maintain a good quality.
<img class="left" src="/images/post/team-discussion.jpg" title="Discussions" >
How we do it: we start with Sprint planning and determine the most important tasks. <strong>Do not waste your time and money!</strong> Determine the most important tasks! If necessary, programmer and product owner create more detailed specification. <strong>Do not create unnecessary documentation!</strong> The created specification often just one page! We have been using sketchbook, whiteboard and UML drawing program. After all, we publish it.</p>

<blockquote><p>We know, why we have been using a particular tool, this is a <strong>conscious choice</strong>.</p></blockquote>

<p>Some examples:</p>

<ol>
<li>We do not use Eclipse editor, because NetBeans is simpler. We can start Maven project with it faster and cleaner. Tool version update is bug free. Code does not depend on it.</li>
<li>We do not use Ant, but Maven. Maven has dependecy managment, life cycle, and is capable to release software from CLI.</li>
<li>We use DVCS: Mercurial and Git. We can commit offline, and merge branch between developer. It is tracking changesets, not files.</li>
<li>We have been writing unit test. This is a standard solution for testing our daily work: all unit test runs from NetBeans after every code compile, so we are always testing all changes!</li>
<li>We use Spring Framework, because "Write Once - Run Anywhere" is working. Spring upgrade on any project are seamless. It doesn't accumulate technical debt. It is free and costless!</li>
</ol>


<p><img class="left" src="/images/post/cucumber.jpg" title="Cucumber feature file" > Jenkins CI server start testing <em>Integration Tests</em> and <em>Automated Acceptance Test</em> after code have been commited to DVCS. <a href="http://cukes.info/">Cucumber</a> is the best tool for AAT (Automated Acceptance Test). I've tested several other BDD tools (Spock, jBehave, etc.) before we start using Cucumber. Cucumber feature text is written in a business-readable domain-specific language and serves as documentation, automated tests and development-aid - all rolled into one format! Read more: <a href="http://pragprog.com/book/hwcuc/the-cucumber-book">The Cucumber Book: Behaviour-Driven Development for Testers and Developers</a> - sample codes has been written in ruby, but useful to Java developers too.</p>

<blockquote><p>Do not waste your time to try testing all feature with AAT!</p></blockquote>

<p>Most important features has been tested with AAT, but not all. We do manual test before we release a new version (UAT), focused on new features (product backlog items). At the end of the Sprint, we show features at Sprint Review Meeting.</p>

<h2>Conclusion</h2>

<p>Choose your tools for <em>Continuous Delivery</em> and do not forget: <strong>Optimize the Whole</strong> and <strong>Focus on the Entire Value Stream</strong></p>
]]></content>
  </entry>
  
</feed>
